#!/usr/bin/env python3

# Copyright Â© 2022 Pavel Tisnovsky
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Script to generate JSON with image details information.
"""

import json
import string
import random
from datetime import timedelta, datetime
from argparse import ArgumentParser


# stub for the data structure to be serialized into JSON
image_details = {"data":[],
                 "page": 0,
                 "page_size": 100,
                 "total": 1}


def cli_arguments():
    """Retrieve all CLI arguments provided by user."""
    # First of all, we need to specify all command line flags that are
    # recognized by this tool.
    parser = ArgumentParser()

    parser.add_argument(
            "-o",
            "--output",
            dest="output",
            default="image_details.json",
            required=False,
            help="Output file")

    # Now it is time to parse flags, check the actual content of command line
    # and fill-in the object named `args`.
    return parser.parse_args()


def generate_id(length):
    """Generate ID of specified length."""
    letters = string.digits + "abcdef"
    return ''.join(random.choice(letters) for i in range(length))


def generate_date(start, end):
    """Generate date between two specified dates."""
    delta = end - start
    int_delta = (delta.days * 24 * 60 * 60) + delta.seconds
    random_second = random.randrange(int_delta)
    return start + timedelta(seconds=random_second)


def date_between(start, end):
    """Formatted date between two specified dates."""
    simple_format = "%Y-%m-%d"
    d1 = datetime.strptime(start, simple_format)
    d2 = datetime.strptime(end, simple_format)
    date = generate_date(d1, d2)

    date_format = "%Y-%m-%dT%H:%M:%S.%f%z+00:00" # poor man's TZ info
    return date.strftime(date_format)


def gen_package_version():
    """Generate package name + version."""
    p = random.choice([
        "acl",
        "add-apt-key",
        "usb-modeswitch",
        "vim-common",
        "vim-gtk",
        "vim-gui-common",
        "vim-runtime",
        "vim-tiny",
        "syslinux-common",
        "syslinux-legacy",
        "syslinux-utils",
        "syslinux",
        "system-config-printer-common",
        "system-config-printer-gnome",
        "system-config-printer-udev",
        "system-config-printer",
        "system-tools-backends",
        "systemd-coredump",
        "systemd-sysv",
        "systemd",
        "openssl-libs"])
    v = random.choice([
        "2.2.53-6",
        "1.0-0.5",
        "2.5.2+repack0",
        "2:8.1.2269",
        "3:6.04~git20190206.bf6db5b4+dfsg1-2",
        "2:3.63+dfsg-2ubuntu9",
        "1.5.12",
        "2.10.2-3",
        "245.4",
        "1.1.1g-12"])
    return p, p + "-" + v


def gen_version():
    """Generate just version info."""
    return "{}.{}.{}".format(random.randint(1,5), random.randint(1,5), random.randint(1,5))


def gen_freshness_grades():
    cnt = random.randint(1, 10)
    ret = []
    for i in range(cnt):
        # TODO dates on one linear scale?
        ret.append({"creation_date": date_between("2000-01-01", "2022-01-12"),
                    "start_date": date_between("2000-01-01", "2022-01-12"), 
                    "end_date": date_between("2000-01-01", "2022-01-12"),
                    "grade": random.choice("ABCDEF")})
    return ret


def gen_architecture():
    """Generate architecture."""
    return random.choice(["amd64", "arm32", "aarch64", "m68k"])


def gen_build_release():
    """Generate build release info."""
    y = random.randint(2020, 2022)
    m = random.randint(1, 12)
    d = random.randint(1, 28)
    H = random.randint(1, 23)
    m = random.randint(0, 59)

    return "{:04d}{:02d}{:02d}{:02d}{:02d}.po".format(y, m, d, H, m)


def gen_env_variables():
    """Generate environment variables."""
    major = random.randint(1, 5)
    minor = random.randint(0, 10)
    patch = random.randint(0, 10)

    build_release = gen_build_release()
    
    commit = generate_id(40)
    short_commit = commit[:8]

    return [
          "__doozer=merge",
          "BUILD_RELEASE={}".format(build_release),
          "BUILD_VERSION=v{}.{}.{}".format(major, minor, patch),
          "OS_GIT_MAJOR={}".format(major),
          "OS_GIT_MINOR={}".format(minor),
          "OS_GIT_PATCH={}".format(patch),
          "OS_GIT_TREE_STATE=clean",
          "OS_GIT_VERSION={}.{}.{}-{}-{}".format(major, minor, patch, build_release, short_commit),
          "SOURCE_GIT_TREE_STATE=clean",
          "OS_GIT_COMMIT={}".format(short_commit),
          "SOURCE_DATE_EPOCH=1609769783",
          "SOURCE_GIT_COMMIT={}".format(commit),
          "SOURCE_GIT_TAG=v4.4-imagestream-1-45-{}".format(short_commit),
          "SOURCE_GIT_URL=https://github.com/example",
          "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
          "container=oci"
            ]


def gen_labels():
    """Generate labels."""
    keys = (
            "License",
            "architecture",
            "build-date",
            "com.redhat.build-host",
            "com.redhat.component",
            "com.redhat.license_terms",
            "description",
            "distribution-scope",
            "io.k8s.description",
            "io.k8s.display-name",
            "io.openshift.build.commit.id",
            "io.openshift.build.commit.url",
            "io.openshift.build.source-location",
            "io.openshift.expose-services",
            "io.openshift.maintainer.component",
            "io.openshift.maintainer.product",
            "io.openshift.tags",
            "maintainer",
            "name",
            "release",
            "summary",
            "url",
            "vcs-ref",
            "vcs-type",
            "vendor",
            "version",
            )
    return [{"name":key,
             "value":generate_id(10)}
             for key in keys]

def generate_layers_sizes(count):
    """Generated layesrs and its sizes."""
    layers = ["sha256:" + generate_id(64) for i in range(count)] # TODO refactor
    sizes = [random.randint(1000, 10000000) for i in range(count)]
    return layers, sizes


def uncompressed_layer_sizes(layers, sizes):
    ret = []
    for i in range(len(layers)):
        ret.append({"layer_id": layers[i],
                    "size_bytes": sizes[i]})

    return ret


class ImageDetails:
    """ImageDetails class represents metainformation about one image to be stored in JSON file."""

    def __init__(self):
        """Construct new object representing image details."""
        id = generate_id(24)

        self._id = generate_id(24)
        self._links = {
                "rpm_manifest": {
                    "href": f"/v1/images/id/{id}/rpm-manifest"
                    },
                "vulnerabilities": {
                    "href": f"/v1/images/id/{id}/vulnerabilities-manifest"
                    }
                }
        self.architecture = gen_architecture()

        package, version = gen_package_version()
        self.brew = {
                "build": version,
                "completion_date": date_between("2000-01-01", "2022-01-12"),
                "nvra": version,
                "package": package
                }

        self.certificationsNo = random.randint(0, 2)
        self.certified = self.certificationsNo > 0

        # not relevant
        self.content_sets = [
            "rhocp-4.8-for-rhel-8-x86_64-rpms",
            "rhel-8-for-x86_64-baseos-beta-rpms",
            "rhel-8-for-x86_64-appstream-beta-rpms"]
        self.content_setsNo = 3

        self.cpe_ids = []
        self.cpe_ids_no = 0
        self.cpe_ids_rh_base_images_no = 0
        self.created_by = random.choice(["foo", "bar", "baz"])
        self.creation_date = date_between("2000-01-01", "2022-01-12")

        self.docker_image_id = "sha256:" + generate_id(64) # TODO refactor
        self.freshness_grades = gen_freshness_grades()
        self.freshness_grades_no = len(self.freshness_grades)

        self.image_id = "sha256:" + generate_id(64) # TODO refactor
        self.last_update_date = date_between("2000-01-01", "2022-01-12")
        self.last_updated_by = random.choice(["clair", "foo", "bar"])
        self.object_type = "containerImage"

        package, version = gen_package_version()
        self.parent_brew_build = version

        layers, sizes = generate_layers_sizes(10)

        # not needed much
        self.parsed_data = {
                "architecture": gen_architecture(),
                "created": date_between("2000-01-01", "2022-01-12"),
                "docker_version": gen_version(),
                "env_variables": gen_env_variables(),
                "env_variables_no": 16,
                "files": [
                        {"content_url": "http://foo.bar/baz",
                         "filename": "Dockerfile",
                         "key": "buildfile"
                        }
                    ],
                "files_no": 1,
                "labels": gen_labels(), # not needed, use random values
                "labels_no": 26,
                "layers": layers,
                "layers_no": len(layers),
                "os": random.choice(["linux", "windows"]),
                "repos": 0,
                "size": 0,
                "uncompressed_layer_sizes": uncompressed_layer_sizes(layers, sizes)
                }

        self.raw_config = generate_id(100) # not needed, use random value


def main():
    """Entry point to this script."""
    # parse and process and command line arguments.
    args = cli_arguments()

    image_details["data"].append(ImageDetails().__dict__)

    with open(args.output, "w") as fout:
        json.dump(image_details, fout, indent=2)


if __name__ == "__main__":
    main()
