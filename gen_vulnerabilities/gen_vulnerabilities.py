#!/usr/bin/env python3

# Copyright Â© 2022 Pavel Tisnovsky
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Script to generate JSON with specified number of vulnerabilities.

usage: gen_vulnerabilities.py [-h] [-c COUNT] [-o OUTPUT]

optional arguments:
  -h, --help            show this help message and exit
  -c COUNT, --count COUNT
                        Number of vulnerabilities to generate
  -o OUTPUT, --output OUTPUT
                        Output file
"""

import json
import string
import random
from datetime import timedelta, datetime
from argparse import ArgumentParser


# stub for the data structure to be serialized into JSON
vulnerabilities = {"data":[],
                   "page": 0,
                   "page_size": 100,
                   "total": 0}


def cli_arguments():
    """Retrieve all CLI arguments provided by user."""
    # First of all, we need to specify all command line flags that are
    # recognized by this tool.
    parser = ArgumentParser()

    parser.add_argument(
            "-c",
            "--count",
            dest="count",
            default=1,
            required=False,
            type=int,
            help="Number of vulnerabilities to generate")

    parser.add_argument(
            "-o",
            "--output",
            dest="output",
            default="vulnerabilities.json",
            required=False,
            help="Output file")

    # Now it is time to parse flags, check the actual content of command line
    # and fill-in the object named `args`.
    return parser.parse_args()


def generate_id(length):
    """Generate ID of specified length."""
    letters = string.digits + "abcdef"
    return ''.join(random.choice(letters) for i in range(length))


def generate_date(start, end):
    """Generate date between two specified dates."""
    delta = end - start
    int_delta = (delta.days * 24 * 60 * 60) + delta.seconds
    random_second = random.randrange(int_delta)
    return start + timedelta(seconds=random_second)


def date_between(start, end):
    """Formatted date between two specified dates."""
    simple_format = "%Y-%m-%d"
    d1 = datetime.strptime(start, simple_format)
    d2 = datetime.strptime(end, simple_format)
    date = generate_date(d1, d2)

    date_format = "%Y-%m-%dT%H:%M:%S.%f%z+00:00" # poor man's TZ info
    return date.strftime(date_format)


def random_package():
    """Create structure with random package metadata."""
    p = random.choice([
        "acl-2.2.53-6",
        "add-apt-key-1.0-0.5",
        "usb-modeswitch-2.5.2+repack0",
        "vim-common-2:8.1.2269",
        "vim-gtk-2:8.1.2269",
        "vim-gui-common-2:8.1.2269",
        "vim-runtime-2:8.1.2269",
        "vim-tiny-2:8.1.2269",
        "syslinux-common-3:6.04~git20190206.bf6db5b4+dfsg1-2",
        "syslinux-legacy-2:3.63+dfsg-2ubuntu9",
        "syslinux-utils-3:6.04~git20190206.bf6db5b4+dfsg1-2",
        "syslinux-3:6.04~git20190206.bf6db5b4+dfsg1-2",
        "system-config-printer-common-1.5.12",
        "system-config-printer-gnome-1.5.12",
        "system-config-printer-udev-1.5.12",
        "system-config-printer-1.5.12",
        "system-tools-backends-2.10.2-3",
        "systemd-coredump-245.4",
        "systemd-sysv-245.4",
        "systemd-245.4",
        "openssl-libs-1.1.1g-12"])
    return {
            "rpm_nvra": [p + ".el8_3.x86_64"],
            "srpm_nevra": p + ".el8_3.src",
            }


def generate_packages(max_packages):
    """Generate some random packages."""
    cnt = random.randint(1, max_packages)
    return [random_package() for i in range(cnt)]


class Vulnerability:
    """Vulnerability class represents one vulnerability to be stored in JSON file."""

    def __init__(self):
        """Construct new object representing vulnerability."""
        id = generate_id(24)

        self._id = generate_id(24)
        self._links = {
                "image": {
                    "href": f"/v1/images/id/{id}"
                    }
                }
        self.active = random.choice([True, False])
        self.advisory_id = "2021:" + str(random.randrange(1, 9999))
        self.advisory_type = random.choice(["RHSA", "Other", "Type"])
        self.created_by = random.choice(["clair", "other"])
        self.creation_date = date_between("2000-01-01", "2022-01-12")
        self.cve_id = "CVE-2021-" + str(random.randrange(1000, 9999))
        self.image_id = id
        self.last_update_date = date_between("2000-01-01", "2022-01-12")
        self.last_updated_by = random.choice(["clair", "other"])
        self.object_type = "containerImageVulnerability"

        packages = generate_packages(5)
        self.packages = packages
        self.packagesNo = len(packages)
        self.public_date = date_between("2000-01-01", "2022-01-12")
        self.severity = random.choice(["Low", "Medium", "Important", "Urgent"])


def main():
    """Entry point to this script."""
    # parse and process and command line arguments.
    args = cli_arguments()

    for i in range(args.count):
        vulnerabilities["data"].append(Vulnerability().__dict__)

    vulnerabilities["total"] = len(vulnerabilities["data"])

    with open(args.output, "w") as fout:
        json.dump(vulnerabilities, fout, indent=2)


if __name__ == "__main__":
    main()
